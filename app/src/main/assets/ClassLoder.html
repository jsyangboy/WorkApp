<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>FungoLive About</title>
    <meta name="Generator" content="EditPlus">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<h3>
    JDK中提供了三个ClassLoader，根据层级从高到低为：<br>
</h3>
<p>

    Bootstrap ClassLoader，主要加载JVM自身工作需要的类。<br>
    Extension ClassLoader，主要加载%JAVA_HOME%\lib\ext目录下的库类。<br>
    Application ClassLoader，主要加载Classpath指定的库类，<br>
    一般情况下这是程序中的默认类加载器，也是ClassLoader.getSystemClassLoader() 的返回值。<br>
    （这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp <br>
    参数来修改当前程序使用的Classpath）<br>
</p>


<h3>
    什么是双亲委托模型
</h3>

<p>
    JVM加载类的实现方式，我们称为 双亲委托模型：<br>
    如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，<br>
    而是把这个请求委托给自己的父加载器，每一层的类加载器都是如此，<br>
    因此所有的类加载请求最终都应该传送到顶层的Bootstrap ClassLoader中，<br>
    只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。<br>
</p>

<h3>
    为什么要用双亲委托模型
</h3>
<p>

    双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。<br>

    假设有一个开发者自己编写了一个名为java.lang.Object的类，想借此欺骗JVM。<br>
    现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。<br>
    然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在Bootstrap<br>
    ClassLoader的路径下找到java.lang.Object类，并载入它。<br>
</p>
</body>
</html>
