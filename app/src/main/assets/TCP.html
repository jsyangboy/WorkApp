<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>FungoLive About</title>
    <meta name="Generator" content="EditPlus">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<h3>
    校验和
</h3>
<p>
    计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。<br>
    将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。<br>
    发送方：在发送数据之前计算检验和，并进行校验和的填充。<br>
    接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。<br>
</p>

<h3>
    确认应答,序列号
</h3>
<p>
    序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。<br>
    确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。<br>
    也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，<br>
    接收到了哪些数据，下一次的数据从哪里发。<br>

    序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，<br>
    并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。<br>
</p>

<h3>
    超时重传
</h3>
<p>
    在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，<br>
    都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。<br>
    如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，这该怎么办呢？<br>
    而没有收到ACK报文的原因可能是什么呢？<br>

    首先，发送方没有介绍到响应的ACK报文原因可能有两点：<br>

    数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。<br>
    接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了<br>

    TCP在解决这个问题的时候引入了一个新的机制，叫做超时重传机制。<br>
    简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，<br>
    那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，<br>
    便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），<br>
    那么直接丢弃，仍旧发送ACK应答。<br>

    那么发送方发送完毕后等待的时间是多少呢？如果这个等待的时间过长，那么会影响TCP传输的整体效率，<br>
    如果等待时间过短，又会导致频繁的发送重复的包。如何权衡？<br>

    由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间<br>
    （也就是等待的时间）是动态计算的。<br>

</p>

<h3>
    连接管理
</h3>
<p>
    连接管理就是三次握手与四次挥手的过程，在前面详细讲过这个过程，这里不再赘述。<br>
    保证可靠的连接，是保证可靠性的前提。<br>
</p>

<h3>
    流量控制
</h3>
<p>
    接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，<br>
    导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，<br>
    那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。<br>
    而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。<br>
</p>

<h3>
    拥塞控制
</h3>
<p>
    TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。<br>
    网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。<br>
    拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。<br>

    所以TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。<br>
    探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。<br>
    发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，<br>
    首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。<br>
</p>

</body>
</html>
