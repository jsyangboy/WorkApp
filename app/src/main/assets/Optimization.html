<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>FungoLive About</title>
    <meta name="Generator" content="EditPlus">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<h2>
    相关知识
</h2>
<h3>
    app优化要点
</h3>
<p>
    APP使用起来不卡顿,要流畅；<br>
    要省电，省流量；<br>
    要稳定，不闪退(减少闪退，ANR率)；<br>
    APP包尽量要小；<br>
</p>

<h4>
    APP使用起来不卡顿,要流畅；<br>
</h4>
<p>
    UI的绘制。主要原因是绘制的层级深、页面复杂、刷新不合理，<br>
    由于这些原因导致卡顿的场景更多出现在 UI 和启动后的初始界面以及跳转到页面的绘制上。<br>
    数据处理上。导致这种卡顿场景的原因是数据处理量太大，一般分为三种情况，<br>
    一是数据在主线程处理，这个是初级工程师会犯的错误，<br>
    二是数据处理占用 CPU 高，导致主线程拿不到时间片，<br>
    三是内存增加导致 GC 频繁，从而引起卡顿。引起卡顿的原因很多，但不管怎么样的原因和场景，<br>
    最终都是通过设备屏幕上显示来达到用户，归根到底就是显示有问题，<br>
    所以，要解决卡顿，就要先了解 Android 系统的渲染机制。<br>
    UI的过度绘制,绘制的页面有几层View，底层View都是隐藏的，这种的还绘制的话就会造成过度绘制<br>

    andriod的渲染机制<br>

    要在屏幕上显示，其实要经过一系列的过程，Android 应用程序把经过测量、<br>
    布局、绘制后的 surface 缓存数据，通过 SurfaceFlinger 把数据渲染到显示屏幕上， <br>
    通过 Android 的刷新机制来刷新数据。也就是说应用层负责绘制，系统层负责渲染，<br>
    通过进程间通信把应用层需要绘制的数据传递到系统层服务，系统层服务通过刷新机制把数据更新到屏幕上。<br>
    这里我们先介绍一个名词：FPS。FPS 表示每秒传递的帧数。<br>
    在理想情况下，60 FPS 就感觉不到卡，这意味着每个绘制时长应该在16 ms 以内。但是 Android <br>
    系统很有可能无法及时完成那些复杂的页面渲染操作。Android 系统每隔 16ms 发出 VSYNC 信号，<br>
    触发对 UI 进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需的 60FPS。<br>
    如果某个操作花费的时间是 24ms ，系统在得到 VSYNC 信号时就无法正常进行正常渲染，<br>
    这样就发生了丢帧现象。那么用户在 32ms 内看到的会是同一帧画面，这种现象在执行动画或滑动列表比较常见，<br>
    还有可能是你的 Layout 太过复杂，层叠太多的绘制单元，无法在 16ms 完成渲染，最终引起刷新不及时。<br>
    android的View的绘制流程大家应该都知道，都是要经过三大核心步骤：Measure、Layout、Draw。<br>
    具体是如何实现的建议看一下View的源码，这里我就不多说了；如果绘制的层级深，<br>
    页面复杂，在Measure、Layout这二个步骤要花费大量的时间；这样也会造卡顿现象；<br>

</p>
<h5>
    andriod卡顿优化方案
</h5>
<p>

    1.不要在主线程进行网络访问/大文件的IO操作<br>
    2.绘制UI时，尽量减少绘制UI层次；减少不必要的view嵌套，<br>
    可以用Hierarchy Viewer工具来检测，后面会详细讲；<br>
    3.当我们的布局是用的FrameLayout的时候，我们可以把它改成merge,可以避免自己的帧布局<br>
    和系统的ContentFrameLayout帧布局重叠造成重复计算(measure和layout)<br>
    提高显示速度,使用ViewStub：当加载的时候才会占用。不加载的时候就是隐藏的，仅仅占用位置。<br>
    4.在view层级相同的情况下，尽量使用 LinerLayout而不是RelativeLayout；<br>
    因为RelativeLayout在测量的时候会测量二次，而LinerLayout测量一次，可以看下它们的源码；<br>
    5.删除控件中无用的属性;<br>
    6.布局复用.比如listView 布局复用<br>
    7.尽量避免过度绘制（overdraw）,比如：背景经常容易造成过度绘制。由于我们布局设置了背景，<br>
    同时用到的MaterialDesign的主题会默认给一个背景。这时应该把主题添加的背景去掉；<br>
    还有移除 XML 中非必须的背景<br>
    8.自定义View优化。使用 canvas.clipRect()来帮助系统识别那些可见的区域，<br>
    只有在这个区域内才会被绘制。也是避免过度绘制．<br>
    9.启动优化,启动速度的监控，发现影响启动速度的问题所在，优化启动逻辑，<br>
    提高应用的启动速度。比如闪屏页面，合理优化布局，加载逻辑优化，数据准备，<br>

</p>

<p>
    andriod卡顿优化所用到的工具,可以使用系统的工具，打开测试模式下的两个试图，一个是显示view是否过度绘制<br>
    一个是显示gpu渲染的时间条形图
</p>
<h4>
    要省电，省流量；<br>
</h4>
<p>
    1.对一些不常用，或者后台刷新更新不频繁的数据接口，进行本地话，<br>
    2.对一些硬解支持比较好的厂商，在视频播放的时候使用硬解<br>
    3.避免频繁的创建线程，可以使用封装非常好的第三方库，比如RxJava等,使用线程池<br>
    3.合理的使用wack_lock锁，比如在视频播放的时候才使用，避免屏幕常量等<br>
    4.从代码上去优化，比如，局部变量使用final标志,通过代码优化的方式，避免相同的函数频繁进出栈<br>
    5.数据在网络上传输时，尽量压缩数据后再传输，建议用FlatBuffer序列化技术<br>
</p>
<p>
    andriod耗电分析所用到的工具:<br>
    在 Android5.0 以前，在应用中测试电量消耗比较麻烦，也不准确，5.0 :<br>
    之后专门引入了一个获取设备上电量消耗信息的 API:Battery Historian。Battery Historian:<br>
    是一款由 Google 提供的 Android 系统电量分析工具，是一款图形化数据分析工具，:<br>
    直观地展示出手机的电量消耗过程，通过输入电量分析文件，显示消耗情况，:<br>
    最后提供一些可供参考电量优化的方法。

</p>

<h4>
    要稳定，不闪退(减少闪退，ANR率)；<br>
</h4>
<p>
    在测试环节会测试，并且也是最基本的要求
</p>


<h4>
    APP包尽量要小；<br>
</h4>
<h5>
    res资源优化
</h5>
<p>
    （1）只使用一套图片，使用高分辨率的图片。<br>
    （2）UI设计在ps安装TinyPNG插件，对图片进行无损压缩。<br>
    （3）svg图片：一些图片的描述，牺牲CPU的计算能力的，节省空间。使用的原则：简单的图标。<br>
    （4）图片使用WebP(https://developers.google.com/speed/webp/)的格式（Facebook、腾讯、淘宝在用。）<br>
    缺点：加载相比于PNG要慢很多。 但是配置比较高。工具：http://isparta.github.io/<br>
    （5）使用tintcolor(android - Change drawable color programmatically)实现按钮反选效果。<br>
</p>

<h5>
    代码优化
</h5>
<p>
    （1）实现功能模块的逻辑简化<br>
    （2）Lint工具检查无用文件将无用的资源列在“UnusedResources: Unused resources”，删除。<br>
    （3）移除无用的依赖库。<br>
</p>

<h5>
    lib资源优化
</h5>
<p>
    （1）动态下载的资源。<br>
    （2）一些模块的插件化动态添加。<br>
    （3）so文件的剪裁和压缩。<br>
</p>

<h5>
    assets资源优化
</h5>
<p>
    （1）音频文件最好使用有损压缩的格式，比如采用opus、mp3等格式，但是最好不要使用无损压缩的音乐格式<br>
    （2）对ttf字体文件压缩，可以采用FontCreator工具只提取出你需要的文字。比如在做日期显示时，<br>
    其实只需要数字字体，但是使用原有的字体库可能需要10MB大小，<br>
    如果只是把你需要的字体提取出来生成的字体文件只有10KB<br>
</p>

<h5>
    内存优化
</h5>
<p>
    在 Android 系统中有个垃圾内存回收机制，在虚拟机层自动分配和释放内存，<br>
    因此不需要在代码中分配和释放某一块内存，从应用层面上不容易出现内存泄漏和内存溢出等问题，<br>
    但是需要内存管理。Android 系统在内存管理上有一个 Generational Heap Memory 模型，<br>
    内存回收的大部分压力不需要应用层关心， Generational Heap Memory 有自己一套管理机制，<br>
    当内存达到一个阈值时，系统会根据不同的规则自动释放系统认为可以释放的内存，<br>
</p>

<h6>
    减少内存泄漏出现的情景<br>
</h6>
<p>

    1.单例中引用的上下文Context，引用了Activity中的Context, 这样会造成内存泄漏，<br>
    2.要引用Application中的Context;<br>
    3.资源性对象未关闭。比如Cursor、File文件等，往往都用了一些缓冲，在不使用时，应该及时关闭它们。<br>
    4.注册对象未注销。比如事件注册后未注销，会导致观察者列表中维持着对象的引用。<br>
    5.类的静态变量持有大数据对象。<br>
    6.非静态内部类的静态实例。<br>
    7.Handler临时性内存泄漏。如果Handler是非静态的，容易导致 Activity 或 Service 不会被回收。<br>
    8.容器中的对象没清理造成的内存泄漏。<br>
    9.WebView。WebView 存在着内存泄漏的问题，在应用中只要使用一次 WebView，内存就不会被释放掉<br>
</p>

<h6>
    内存优化的方案<br>
</h6>
<p>
    1.对象引用。强引用、软引用、弱引用、虚引用四种引用类型，根据业务需求合理使用不同，选择不同的引用类型。<br>
    2.减少不必要的内存开销。注意自动装箱，增加内存复用，比如有效利用系统自带的资源、<br>
    3.视图复用、对象池、Bitmap对象的复用。<br>
    4.使用最优的数据类型。比如针对数据类容器结构，可以使用ArrayMap数据结构，避免使用枚举类型，<br>
    5.使用缓存Lrucache等等。<br>
    6.图片内存优化。可以设置位图规格，根据采样因子做压缩，用一些图片缓存方式对图片进行管理等等。<br>
    7.图片的压缩几种方案;<br>

</p>

<p>
    内存分析工具

    做内存优化前，需要了解当前应用的内存使用现状，通过现状去分析哪些数据类型有问题，<br>
    各种类型的分布情况如何，以及在发现问题后如何发现是哪些具体对象导致的，<br>
    这就需要相关工具来帮助我们。以下介绍几种内存分析工具<br>


    Memory Monitor<br>
    Memory Monitor 是一款使用非常简单的图形化工具，可以很好地监控系统或应用的内存使用情况．<br>
    主要有以下功能：<br>

    (1).显示可用和已用内存，并且以时间为维度实时反应内存分配和回收情况。<br>
    (2).快速判断应用程序的运行缓慢是否由于过度的内存回收导致。<br>
    (3).快速判断应用是否由于内存不足导致程序崩溃。<br>

    Heap Viewer<br>
    Heap Viewer 的主要功能是查看不同数据类型在内存中的使用情况，<br>
    可以看到当前进程中的 Heap Size 的情况，分别有哪些类型的数据，<br>
    以及各种类型数据占比情况。通过分析这些数据来找到大的内存对象，再进一步分析这些大对象，<br>
    进而通过优化减少内存开销，也可以通过数据的变化发现内存泄漏。<br>

    主要有以下功能：<br>
    (1)实时查看App分配的内存大小和空闲内存大小<br>
    (2)发现Memory Leaks<br>
    Heap Viewer不光可以用来检测是否有内存泄漏，对于内存抖动，我们也可以用该工具检测，<br>
    因为内存抖动的时候，会频繁发生GC，这个时候我们只需要开启Heap Viewer,观察数据的变化，<br>
    如果发生内存抖动，会观察到数据在段时间内频繁更新。<br>

    Allocation Tracker
    Memory Monitor 和 Heap Viewer 都可以很直观且实时地监控内存使用情况，<br>
    还能发现内存问题，但发现内存问题后不能再进一步找到原因，或者发现一块异常内存，<br>
    但不能区别是否正常，同时在发现问题后，也不能定位到具体的类和方法。<br>
    这时就需要使用另一个内存分析工具 Allocation Tracker，进行更详细的分析， <br>
    Allocation Tracker 可以分配跟踪记录应用程序的内存分配，并列出了它们的调用堆栈，<br>
    可以查看所有对象内存分配的周期。<br>

    Memory Analyzer Tool(MAT)<br>
    MAT 是一个快速，功能丰富的 Java Heap 分析工具，通过分析 Java 进程的内存快照 HPROF 分析，<br>
    从众多的对象中分析，快速计算出在内存中对象占用的大小，查看哪些对象不能被垃圾收集器回收，<br>
    并可以通过视图直观地查看可能造成这种结果的对象。<br>

</p>
</body>
</html>
