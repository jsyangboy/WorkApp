<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>FungoLive About</title>
    <meta name="Generator" content="EditPlus">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<h3>组成</h3>
<p>连表数组组成</p>
<h3>冲突</h3>
<p>
    1。开放定址发：
    使用某种探测技术在Hash表中形成一个探测序列，然后沿着这个探测序列依次查找下去，<br>
    当碰到一个空的单元时，则插入其中。基本公式为：hash(key) = （hash(key)+di）mod TableSize。<br>
    其中di为增量序列，TableSize为表长。根据di的不同我们又可以分为线性探测，平方（二次）探测，<br>
    双散列探测。<br>

</p>
<p>
    2。链地址法：<br>
    这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，<br>
    并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。<br>
    链地址法适用于经常进行插入和删除的情况。<br>
</p>
<p>
    3。再哈希：<br>
    这种方法是同时构造多个不同的哈希函数：<br>
　　 Hi=RH1（key）  i=1，2，…，k<br>
　　 当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。<br>
    这种方法不易产生聚集，但增加了计算时间。<br>
</p>
<p>
    4。建立公共溢存区：<br>
    这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，<br>
    一律填入溢出表<br>
</p>

<h3>
    扩容
</h3>
<p>
    那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小*loadFactor[加载因子]时，<br>
    就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，<br>
    那么当hashmap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，<br>
    然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，<br>
    那么预设元素的个数能够有效的提高hashmap的性能。<br>
</p>

<h3>
    为什么加载因子默认是0。75
</h3>

<p>
    这个好回答。 如果是0.5 ， 那么每次达到容量的一半就进行扩容，默认容量是16， <br>
    达到8就扩容成32，达到16就扩容成64， 最终使用空间和未使用空间的差值会逐渐增加，<br>
    空间利用率低下。  如果是1，那意味着每次空间使用完毕才扩容，在一定程度上会增加put时候的时间<br>
    默认负载因子（0.75）在时间和空间成本上提供了很好的折衷
</p>
</body>
</html>
