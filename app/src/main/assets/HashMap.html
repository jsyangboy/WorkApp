<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>FungoLive About</title>
    <meta name="Generator" content="EditPlus">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<h3>组成</h3>
<p>连表数组组成</p>
<h3>冲突</h3>
<p>
    1。开放地址发：
    使用某种探测技术在Hash表中形成一个探测序列，然后沿着这个探测序列依次查找下去，<br>
    当碰到一个空的单元时，则插入其中。基本公式为：hash(key) = （hash(key)+di）mod TableSize。<br>
    其中di为增量序列，TableSize为表长。根据di的不同我们又可以分为线性探测，平方（二次）探测，<br>
    双散列探测。<br>

</p>
<p>
    2。链地址法：<br>
    这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，<br>
    并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。<br>
    链地址法适用于经常进行插入和删除的情况。<br>
</p>
<p>
    3。再哈希：<br>
    这种方法是同时构造多个不同的哈希函数：<br>
　　 Hi=RH1（key）  i=1，2，…，k<br>
　　 当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。<br>
    这种方法不易产生聚集，但增加了计算时间。<br>
</p>
<p>
    4。建立公共溢存区：<br>
    这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，<br>
    一律填入溢出表<br>
</p>
</body>
</html>
