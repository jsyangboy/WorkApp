<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>FungoLive About</title>
    <meta name="Generator" content="EditPlus">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<p>
    垃圾收集器一般必须完成两件事：检测出垃圾、回收垃圾。怎么检测出垃圾？一般有以下几种方法：<br>
</p>
<h3>

    1.引用计数法：<br>
</h3>
<p>
    给一个对象添加引用计数器，每当有一个地方引用它，计数器就加一，<br>
    引用失效就减一。好了，问题来了，如果我有两个对象互相引用，除此之外没有其他任何对象引用他们，<br>
    实际上这两个对象已经无法访问，即我们说的垃圾对象。但他们互相引用，<br>
    计数不为0，所以无法回收。这就是引用计数法的缺陷。<br>
</p>

<h3>
    2.可达性分析算法（也叫根搜索算法）：<br>
</h3>
<p>
    以根集对象为起始点进行搜索，如果有对象不可达的话，即为垃圾对象。<br>
    这里的根集一般包括：java栈中的引用对象、本地方法栈中JNI的引用对象、<br>
    方法区中运行常量池中的引用对象、方法区中静态属性引用的对象、运行中的线程、<br>
    由引导类加载器加载的对象、GC控制的对象。总之，JVM在做垃圾回收的时候，<br>
    会检查堆中的所有对象是否被这些根集中的对象所引用，不能够被引用的对象就会被垃圾回收器回收。<br>

    回收垃圾的算法有：<br>

    1.标记--清除（mark--sweep）：<br>

    算法和名字一样分为两个阶段：标记和清除。标记所有需要回收的对象，之后统一回收。<br>
    这是最基础的算法，后续的回收算法都是基于这个算法扩展的。<br>


    2.复制（copying）：<br>

    此算法把内存空间划分为两个相等的区域，每次只使用其中的一个区域。垃圾回收时，<br>
    遍历当前使用区域的所有对象，将正在使用中的对象复制到另一个区域。此算法每次只处理使用中的对象，<br>
    因此复制成本比较小，同时复制过去之后还能进行相应的内存整理，所以不会出现碎片问题。<br>

    3.标记--整理（mark--compact）:<br>

    此算法结合了标记--清除和复制的有点，也是分两个阶段，第一阶段是从根节点遍历所有对象标记所有能<br>
    被引用的对象，第二阶段遍历整个堆中的对象，清除所有未被标记的对象，并把所有存活对象“压缩”到堆<br>
    的其中一块，按顺序排放。此算法避免了“标记--清除”的碎片问题，也没有“复制”的空间问题。<br>

    4.分代收集算法：<br>

    这是当前商业虚拟机常用的一个垃圾收集算法。分代的垃圾收集策略是基于这样的一个事实：<br>
    不同对象的生命周期是不一样的，因此对于不同生命周期的对象可以采用不同的收集算法，以便提高效率。<br>

</p>
<p>

</p>

</body>
</html>
